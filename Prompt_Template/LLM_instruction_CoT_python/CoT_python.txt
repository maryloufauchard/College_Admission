Task
Implement the student-proposing deferred acceptance algorithm (Gale-Shapley) to solve a many-to-one matching problem for college admissions.

Instance Format
The instance will contain the following elements: 
    Num. students: Integer, the number of students
    Num. colleges: Integer, the number of colleges
    Students: List of student names
    Colleges: List of college names
    Capacities: Dictionary, each college mapped to its capacity (integer)
    Student preferences: Dictionary, each student is mapped to a list of tuples (rank,college) 
    College preferences: Dictionary, each college is mapped to a list of tuples (rank, student)
Ranks are integers where 1 indicates the highest preference.

Constraints
The output matching must satisfy the following:
Feasibility: 
    Each student is matched to at most one college.
    No college is matched with more students than its capacity.
Stability: 
    There must be no blocking pair (student, college) such that: 
        The student prefers the college over their current match, and
        The college either has not reached its capacity or prefers the student to at least one of its current matches.
Optimality: 
    Among all stable matchings, students are matched to the best possible college based on their preferences.

Output Format
Return the matching as a list of tuples of the form (student, match). If a student is unmatched, use “nothing” as the college. 

Instance
The instance to solve is :
[ADD INSTANCE HERE]


Step by Step Process:
priority_ranks = {
   c: {s: rank for rank, s in enumerate(priority)}
   for c, priority in college_priorities.items()
}


proposals = {s: deque(prefs) for s, prefs in student_prefs.items()}
college_matches = defaultdict(list)
student_match = {s: None for s in students}


while True:
   free_students = [s for s in students if student_match[s] is None and proposals[s]]
   if not free_students:
       break


   for student in free_students:
       college = proposals[student].popleft()
       college_matches[college].append(student)


       accepted = sorted(
           college_matches[college],
           key=lambda s: priority_ranks[college][s]
       )[:capacities[college]]


       for s in college_matches[college]:
           if s in accepted:
               student_match[s] = college
           else:
               student_match[s] = None
       college_matches[college] = accepted

Instruction
Return only the final matching as a list of tuples.

Final Matching : 